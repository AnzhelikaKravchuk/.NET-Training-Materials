# Репозиторий вопросов и ответов для подготовки к собеседованию - здесь только правильные ответы

<a name="content"></a>

+ [ООП и паттерны проектирования](#1)
+ [.NET](#2)
+ [С\#](#3)

## <a name="1"></a> ООП и паттерны проектирования

- Какие принципы ООП вы знаете? Опишите их.

> **Абстракция** - выделение существенных характеристик некоторого объекта, которые отличают его от всех других видов объектов и, таким образом, четко определяют его концептуальные границы с точки зрения наблюдателя. (Гради Буч. Объектно-ориентированный анализ и проектирование с примерами приложений).
>
> **Инкапсуляция** - это процесс отделения друг от друга элементов объекта, определяющих его устройство и поведение; инкапсуляция служит для того, чтобы изолировать контрактные обязательства абстракции от их реализации. (Гради Буч. Объектно-ориентированный анализ и проектирование с примерами приложений).
> 
> **Наследование** - Наследование реализации это свойство системы, позволяющее описать новый класс на основе существующего с целью повторного использования, расширения и изменения функциональности базового класса.
>
> **Полиморфизм** - способность объектов с различной реализацией предоставлять один общий интерфейс. Позволяет добавлять дополнительные реализации без добавления условий и изменения структуры кода.
>
> [Подробнее...](https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija)

- Какие принципы SOLID вы знаете? Опишите их.

> - S – Single Responsibility Principle (Принцип единственной ответственности).
> У класса/модуля должна быть лишь одна причина для изменения.
> - O – Open-Closed Principle (Принцип открытости/закрытости).
> Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации.
> - L – Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
> Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. Наследующий класс должен дополнять, а не изменять базовый.
> - I – Interface Segregation Principle (Принцип разделения интерфейса).
> Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.
> - D – Dependency Inversion Principle (Принцип инверсии зависимостей).
> Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
>
> [Подробнее...](http://sergeyteplyakov.blogspot.com/2014/10/solid.html)

- Какие паттерны проектирования вы знаете? Перечислите/Опишите.

> Название|Определение|Схема
>  -|-|-
> Стратегия | Определяет набор алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.|[![Strategy](https://refactoring.guru/images/patterns/diagrams/strategy/structure.png)](https://refactoring.guru/images/patterns/diagrams/strategy/structure.png)
> Декоратор|Динамически наделяет объект новыми возможностями и является гибкой альтернативой субклассированию (то есть наследованию от супер класса) в области расширения функциональности.|[![Decorator](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)
> Адаптер|Предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного паттерна мы можем использовать вместе классы с несовместимыми интерфейсами.|[![Adapter](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png)](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png)
> Шаблонный метод|Определяет общий алгоритм поведения подклассов, позволяя им переопределить отдельные шаги этого алгоритма без изменения его структуры.|[![Template method](https://refactoring.guru/images/patterns/diagrams/template-method/structure.png)](https://refactoring.guru/images/patterns/diagrams/template-method/structure.png)
> Фабричный метод|Определяет интерфейс для создания объекта, но непосредственное решение о том, объект какого класса создавать происходит в подклассах. То есть паттерн предполагает, что базовый класс делегирует создание объектов классам-наследникам.|[![Factory method](https://refactoring.guru/images/patterns/diagrams/factory-method/structure.png)](https://refactoring.guru/images/patterns/diagrams/factory-method/structure.png)
> Абстрактная фабрика|Предоставляет интерфейс для создания семейств взаимосвязанных объектов с определенными интерфейсами без указания конкретных типов данных объектов.|[![Abstract factory](https://refactoring.guru/images/patterns/diagrams/abstract-factory/structure.png)](https://refactoring.guru/images/patterns/diagrams/abstract-factory/structure.png)
> Итератор|Предоставляет абстрактный интерфейс для последовательного доступа ко всем элементам составного объекта без раскрытия его внутренней структуры.|[![Iterator](https://refactoring.guru/images/patterns/diagrams/iterator/structure.png)](https://refactoring.guru/images/patterns/diagrams/iterator/structure.png)
> Компоновщик|Объединяет группы объектов в древовидную структуру по принципу "часть-целое и позволяет клиенту одинаково работать как с отдельными объектами, так и с группой объектов.|[![Composite](https://refactoring.guru/images/patterns/diagrams/composite/structure.png)](https://refactoring.guru/images/patterns/diagrams/composite/structure.png)
> Одиночка|Гарантирует, что для определенного класса будет создан только один объект, а также предоставит к этому объекту точку доступа.|[![Singleton](https://refactoring.guru/images/patterns/diagrams/singleton/structure.png)](https://refactoring.guru/images/patterns/diagrams/singleton/structure.png)
> Наблюдатель|Использует отношение "один ко многим". В этом отношении есть один наблюдаемый объект и множество наблюдателей. И при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.|[![Observer](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)
> Комманда|Позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. Этот объект запроса на действие и называется командой. При этом объекты, инициирующие запросы на выполнение действия, отделяются от объектов, которые выполняют это действие.|[![Command](https://refactoring.guru/images/patterns/diagrams/command/structure.png)](https://refactoring.guru/images/patterns/diagrams/command/structure.png)
> Состояние|Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния.|[![State](https://refactoring.guru/images/patterns/diagrams/state/structure.png)](https://refactoring.guru/images/patterns/diagrams/state/structure.png)
> Фасад|Позволяет скрыть сложность системы с помощью предоставления упрощенного интерфейса для взаимодействия с ней.|[![Facade](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)
>
> [Подробнее...](https://metanit.com/sharp/patterns/) | [Подробнее...](https://refactoring.guru/design-patterns) | [Видео](https://www.youtube.com/watch?v=v9ejT8FO-7I)

- Что означает буква V в аббревиатуре MVC?

> **Представление (View)** отвечает за отображение данных модели пользователю, реагируя на изменения модели

- Какими DI-контейнерами вы пользовались при разработке?

> - [Castle Windsor](http://www.castleproject.org/download/)
> - [Autofac](https://autofac.org/)
> - [Ninject](http://www.ninject.org/)

- Отличие композиции от агрегации?

> Разница между композицией и агрегацией заключается в том, что в случае композиции целое явно контролирует время жизни своей составной части (часть не существует без целого), а в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано (например, составная часть передается через параметры конструктора).
>
> [Подробнее...](http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html)

- Синглетон vs статический класс?

> *|Singleton|Static class
> -|-|-
> Количество точек доступа|Одна (и только одна) точка доступа — статическое поле Instance|N (зависит от количества публичных членов класса и методов)
> Наследование классов|Возможно|Невозможно — статические классы не могут быть экземплярными, поскольку нельзя создавать экземпляры объекты статических классов
> Наследование интерфейсов|Возможно, безо всяких ограничений|Невозможно по той же причине, по которой невозможно наследование классов
> Возможность передачи в качестве параметров|Возможно, поскольку Singleton предоставляет реальный объект|Отсутствует
> Контроль времени жизни объекта|Возможно — например, отложенная инициализация (или создание по требованию)|Невозможно по той же причине, по которой невозможно наследование классов
> Использование абстрактной фабрики для создания экземпляра класса|Возможно|Невозможно по причине осутствия самой возможности создания экземпляра
> Сериализация|Возможно|Неприменима по причине отсутствия экземпляра
>
>[Подробнее...](https://habr.com/ru/post/103681/)

- Какие виды внедрения зависимостей вы знаете? [Ответ](https://rsdn.org/article/patterns/14-22-pattern/14-22-pattern.xml)

[Up](#content)

## <a name="2"></a> .NET

- Что такое сборка?

>Сборка в .NET - логическая группировка одного или нескольких управляемых модулей и файлов ресурсов.
Самая маленькая единица с точки зрения развертывания, повторного использования, безопасности и управления версиями.
Сборка - коллекция типов и ресурсов, которые собраны для совместной работы и
которые вместе образуют логическую функциональную единицу.
>[Подробнее...](https://docs.microsoft.com/ru-ru/dotnet/framework/app-domains/assemblies-in-the-common-language-runtime)

- Что такое CLR?

>Common Language Runtime (общеязыковая исполняющая среда) — исполняющая среда для выполнения IL-кода (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования. Среда CLR является реализацией спецификации CLI (англ. Common Language Infrastructure). Код, выполняемый под управлением CLR, называют управляемым кодом. CLR отвечает за:
>
> 1. безопасность типов;
> 2. строгую типизацию;
> 3. обработку исключений;
> 4. сборку мусора;
> 5. управление памятью;
> 6. управление потоками;
> 7. вызов методов;

- Что такое GC?

> Garbage collector (сборщик мусора) вызывается тогда, когда в куче(small object heap) не осталось свободной памяти. В этом момент работа программы приостанавливается, и сборщик мусора анализирует, существует ли хоть одна ссылка на конкретный участок памяти. Если таковых нет, данный участок очищается. Как правило, объекты в куче располагаются неупорядочено, между ними могут иметься пустоты. Поэтому после очистки памяти в результате очередной сборки мусора оставшиеся объекты перемещаются в один непрерывный блок памяти. Вместе с этим происходит обновление ссылок, чтобы они правильно указывали на новые адреса объектов.

- Что такое поколения?

> Чтобы снизить издержки от работы сборщика мусора, все объекты в куче разделяются по поколениям: 0, 1 и 2-е. К поколению 0 относятся новые объекты, которые еще ни разу не подвергались сборке мусора. К поколению 1 относятся объекты, которые пережили одну сборку, а к поколению 2 - объекты, прошедшие более одной сборки мусора. Когда сборщик мусора приступает к работе, он сначала анализирует объекты из поколению 0. Те объекты, которые остаются актуальными после очистки, повышаются до поколения 1. Если после обработки объектов поколения 0 все еще необходима дополнительная память, то сборщик мусора приступает к объектам из поколения 1. Те объекты, на которые уже нет  ссылок, уничтожаются, а те, которые по-прежнему актуальны, повышаются до поколения 2. Поскольку объекты из поколения 0 являются более молодыми и нередко находятся в адресном пространстве памяти рядом друг с другом, то их удаление проходит с наименьшими издержками.

- Можно ли выгрузить сборку из домена приложения?
- Какие интерфейсы .NET Framework вы знаете? Перечислите.
- Какие классы-коллекции .NET Framework вы знаете? Перечислите.
- В чем разница между типом-значением и типом-ссылкой?
- В чем разница между типом-значением и типом-ссылкой?

> В переменной типа значения храниться само значение, а в переменной ссылочного типа хранит адрес на объект в куче.  
> В результате присвоения в переменную значимого типа копируется значение. В результате мы имеем две переменные, которые хранят одинаковое значение. Если изменить значение одной переменной, то в другой переменной значение останется прежним.  
> В результате присвоения переменной ссылочного типа копируется адрес объекта в куче. В результате мы имеем две переменные ссылочного типа, которые указывают на один объект в куче. При изменении состояния объекта, изменения будут доступны во всех ссылочных переменных, которые указывают на данный объект.

[Up](#content)

## <a name="3"></a> С\#

- Что такое класс?

> Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт)  
> Класс является ссылочным типом данных.  
> Модификаторами невложенных классов являются public, internal, abstract, sealed, static, unsafe, partial.  
> Члены класса: поля, методы, свойства, индексаторы, события, конструкторы, перегруженные операции, вложенные типы, финализатор.  
> [Подробнее...](https://habr.com/ru/post/87119/)

- Что такое объект?

> Объект (экземпляр) - это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.  
> [Подробнее...](https://habr.com/ru/post/87119/)

- Что такое ссылка?

> Ссылка - это понятие времени информации. Ее значение либо null, либо она присоединена к объекту,
который она однозначно идентифицирует.
Ссылка - некая порция данных, которая однозначно идентифицирует объект в куче. По сути содержит адрес, по которому объект находится в памяти.

- Что такое конструктор?

> Конструктор - это метод, который выполняется при создании объекта.
> Имя метода-конструктора должно совпадать с именем класса.
> Конструктор может иметь следующие модификаторы:
>
> Наименование|Модификаторы
> -|-
> Статический модификатор|static
> Модификатор доступа|public, internal, private, protected
> Модификатор неуправляемого|unsafe extern
>
> Виды конструкторов: конструктор по умолчанию, конструктор с параметрами, конструктор копирования.

- Что такое деструктор?

> [Финализируемые объекты](https://metanit.com/sharp/tutorial/8.2.php)  
> [Есть ли деструктор в C#?](https://habr.com/ru/post/122639/)

- Какие виды наследования Вы знаете?

> - Наследование "is a" - связь между базовым классом и одним (несколько) производными классами.
Производные классы рассматриваются как специализированные версии базового класса, то есть как подтипы базового класса. Некоторый класс может наследоваться с помощью такой только от одного класса. Наследник может выдать себя за что-то базовое (основа полиморфного поведения).
> - Наследование "implement" - класс может реализовывать один или несколько интерфейсов.  
Множественное наследование не поддерживается между классами, но оно поддерживается между интерфейсами.

- Перечислите основные отличия абстрактного класса от интерфейса.

> Отличия|Абстрактный класс|Интерфейс
> -|-|-
> Какие могут быть члены типа|Все возможные члены типа и вложенные типы. Абстрактные методы, свойства, индексаторы и события|Методы, свойства, индексаторы, события
> Модификаторы доступа для членов типа|Public, internal, private (по умолчанию), protected, protected internal, private protected (v7.2) |Public (по умолчанию)
> Статические члены типа|Может содержать статические члены|Не содержит статических членов
> Реализация членов типа по умолчанию|Члены абстрактного класса могут иметь стандартную реализацию|Не допускают реализации членов по умолчанию
> Какие типы могут наследовать (реализовывать)|Классы|Классы, структуры
>
> [Подробнее...](https://docs.google.com/document/d/1RRyjXgxWuEKvUk1zAN9fstpnqmkD8yzb_VF9h0EWffE/edit?usp=sharing)

- Что такое перегрузка методов?

> Возможность использовать одинаковые имена в пределах одного класса для методов, которые
отличаются сигнатурой. Тип возвращаемого значения не является частью сигнатуры в целях перегрузки метода.
> То, что базируется на атрибутах (ref, out параметры, например), то они не вмешиваются в сценарий
перегрузки.
>
> - void SomeMethod(out int x);
> - void SomeMethod(ref int x) - не будет перегрузкой.

- Что такое переопределение методов? Какие методы можно переопределять?

> Переопределение - намеренное изменение или расширение абстрактной или виртуальной реализации унаследованного метода, свойства, индексатора или события базового классанамеренное изменение или расширение абстрактной или виртуальной реализации унаследованного метода, свойства, индексатора или события базового класса.  
> Переопределить можно методы, которые в базовом классе помечены как virtual, abstract, override.

- Что такое механизм разрешения перегрузки (Overload resolution)?

> Представляет собой механизм времени компиляции для выбора наилучшего функционального
элемента из всех возможных функциональных элементов для вызова при заданном списке аргументов.

- Что такое статический класс?

> Класс считается статическим, если при его описании перед ключевым словом class используется
ключевое слово static.
> Определение класса статическим, означает то, что этот класс является набором только статических сущностей
(полей, методов, свойств).
> Экземпляры такого класса создать нельзя. Ограничения:
>
> - не участвует в наследовании (является запечатанным);
> - не может содержать члены с атрибутами доступа protected, protected internal;

- Что такое статический метод?

> Метод, который определяет общее для всех объектов поведение (в нестатическом классе).
Метод принадлежит всему классу, как типу данных.
Статические методы могут обращаться только к статическим членам класса.

- Что такое null?

> Ключевое слово null - это литерал, который представляет нулевую ссылку, то есть ссылку,
которая не ассоциирована ни с каким объектом.
null - значение по умолчанию для переменных ссылочного типа данных.

- Что означает ключевое слово var?
- Что означает ключевое слово dynamic?
- В чём разница между var и dynamic?
- Что такое сериализация?
- Что такое неизменяемый класс?

## ASP.NET MVC + Web

- Что такое WWW?
- Что такое веб-сервер и браузер? Как они между собой взаимодействуют?
- Что такое URL? URI? URN? Приведиите пример.
- Что такое HTML?
- Какие протоколы передачи данных вы знаете? На каких уровнях они работают?
- HTTP протокол.
- Что такое IP-адрес? Из чего он состоит?
- Что происходит при отправке запроса на сервер (подробно)
- Что такое ASP.NET?
- Как расшифровывается MVC, что это такое?
- IIS Pipeline.
- ASP.NET MVC pipeline.

## Тестирование

- Что такое юнит-тестирование?
- Что такое TDD?
- Что такое BDD?
- Какие фреймворки для тестирования вы знаете.
- Что такое исключение?
- Зачем нужны Mock-объекты? [Ответ](https://habr.com/ru/post/116372/) | [Отличие Mock от Stub](http://sergeyteplyakov.blogspot.com/2011/12/blog-post.html)

## Общие вопросы

- Что такое типизация?
> Типизация - это способ защититься от использования объектов одного класса вместо другого, или по крайней мере управлять таким использованием. Конкретный язык программирования может иметь сильный или слабый механизм типизации, и даже не иметь вообще никакого, оставаясь объектно-ориентированным. Например, в Eiffel соблюдение правил использования типов контролируется непреклонно, - операция не может быть применена к объекту, если она не зарегистрирована в его классе или суперклассе. В сильно типизированных языках нарушение согласования типов может быть обнаружено во время трансляции программы. С другой стороны, в Smalltalk типов нет: во время исполнения любое сообщение можно послать любому объекту, и если класс объекта (или его надкласс) не понимает сообщение, то генерируется сообщение об ошибке. Нарушение согласования типов может не обнаружиться во время трансляции и обычно проявляется как ошибка исполнения. C++ тяготеет к сильной типизации, но в этом языке правила типизации можно игнорировать или подавить полностью. 

- Что такое статически типизированный язык? Примеры. [Ответ](https://habr.com/ru/post/161205/)
- Что такое динамически типизированный язык? Примеры. [Ответ](https://habr.com/ru/post/161205/)
- Что такое слабо и сильно типизированные языки? Примеры. [Ответ](https://habr.com/ru/post/161205/)
- Что такое критическая секция?
- Что такое система контроля версий? Какими системами контроля версий вы пользуетесь/знаете?
- Что такое "well formed" XML документ?
- Что такое "valid" XML документ?
- Способы валидации XML документа?
- Что такое SQL-инъекция?
- В чем разница между операторами & и &&?

> Оператор &&  - логический оператор И.  
> Оператор & поддерживается в трех формах: унарный оператор address-of (взятие адреса), побитовое логическое "И" и логический оператор "И".  
>
> Логический оператор & вычисляет логическое И всех своих операндов.  
> x & y  
> если x=true, проверяется y, возвращается результат операции  
> если x=false, проверяется y, возвращается false  
> [Подробнее...](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/and-operator)
>
> Логический оператор && (также известный как "сокращенный" логический оператор И) вычисляет логическое И всех операндов.  
> x && y  
> если x=true, проверяется y, возвращается результат операции  
> если x=false, y не вычисляется, возвращается false  
> [Подробнее...](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/conditional-and-operator)

- Каков результат операции 1 xor 1?

> Операция XOR (исключающее ИЛИ)  
> Таблица истинности для операции XOR  
>
> x |y |x xor y
> -|- |-
> 0|0 |0
> 0|1 |1
> 1|0 |1
> 1|1 |0
>
> В C# операцию логического ИЛИ выполняет оператор ^ [Подробнее...](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/xor-operator).  
> [О битовых операциях](https://tproger.ru/translations/bitwise-operations/)

- Сколько времени займет получение элемента из одномерного массива, связного списка, бинарного дерева поиска, хэш-таблицы? А если в этих структурах будет миллион элементов?
>
> Структура|Средняя сложность
> -|-
> массив (по индексу)|O(1)
> массив (по значению)|O(n)
> связный список|O(n)
> бинарное дерево поиска|O(log(n))
> хэш-таблица|O(1)
>

- Что такое потокобезопасный код?
- Какие вы знаете о объектах синхронизации?

- Чем отличается компилятор от интерпретатора?

> Компилятор - это программа или техническое средство, которое анализирует и транслирует исходный код в машинный или байт-код без его выполнения. Скомпилированная программа зависит от ОС под которую была скомпилирована, но выполняется самостоятельно без компилятора и исходного кода. Скорость выполнения скомпилированной программы выше, чем интерпретируемой.  
> Интерпретатор - это программа или техническое средство, которое построчно анализирует, обрабатывает и выполняет исходный код программы. Соответственно программа не зависит от ОС на которой выполняется, но для выполнения программы необходимы интерпретатор и исходный код. Скорость выполнения программы ниже, чем у скомпилированной.(Гради Буч. Объектно-ориентированный анализ и проектирование с примерами приложений).

- Какие виды структур данных вы знаете?

> [Стек](https://ru.wikipedia.org/wiki/Стек), [Очередь](https://ru.wikipedia.org/wiki/Очередь_(программирование)), [Массив](https://ru.wikipedia.org/wiki/Массив_(тип_данных)), [Связный список](https://ru.wikipedia.org/wiki/Связный_список), [Множество](https://ru.wikipedia.org/wiki/Множество_(тип_данных)), [B-дерево](https://ru.wikipedia.org/wiki/B-дерево), [Двоичное дерево поиска](https://ru.wikipedia.org/wiki/Двоичное_дерево_поиска), [АВЛ-дерево](https://ru.wikipedia.org/wiki/АВЛ-дерево), [Красно-черное дерево](https://ru.wikipedia.org/wiki/Красно-чёрное_дерево), [Куча](https://ru.wikipedia.org/wiki/Куча_(структура_данных)), [Хэш-таблица](https://ru.wikipedia.org/wiki/Хеш-таблица).

- Какие алгоритмы сортировки вы знаете?

> ### Алгоритмы устойчивой сортировки
>
> Название|Средняя вычислительная сложность|Дополнительная память
> -|-|-
> [Bubble sort (Пузырьком)](https://ru.wikipedia.org/wiki/Сортировка_пузырьком)|O(n^2)|-
> [Cocktail sort (Перемешиванием, шейкерная)](https://ru.wikipedia.org/wiki/Сортировка_перемешиванием)|O(n^2)|-
> [Insertion sort (Вставками)](https://ru.wikipedia.org/wiki/Сортировка_вставками)|O(n^2)|-
> [Merge sort (Cлиянием)](https://ru.wikipedia.org/wiki/Сортировка_слиянием)|O(n log(n))|О(n)
> [Radix sort (Поразрядная)](http://algolist.manual.ru/sort/radix_sort.php)|O(nk), где k — число разрядов.|O(n)
>
> ### Алгоритмы неустойчивой сортировки
>
> Название|Средняя вычислительная сложность|Дополнительная память
> -|-|-
> [Selection sort (Выбором)](https://ru.wikipedia.org/wiki/Сортировка_выбором)|O(n^2)|-
> [Сomb sort (Расчёской)](https://ru.wikipedia.org/wiki/Сортировка_расчёской)|O(n^2)|-
> [Shell sort (Шелла)](https://ru.wikipedia.org/wiki/Сортировка_Шелла)|~O(n^(4/3)|-
> [Heapsort (Пирамидальная)](https://ru.wikipedia.org/wiki/Пирамидальная_сортировка)|O(n log(n))|-
> [Quick sort (Быстрая)](https://ru.wikipedia.org/wiki/Быстрая_сортировка)|O(n log(n))|-
  
- Какие поисковые алгоритмы Вы знаете?
- Что такое куча и стек процесса?
- Как между собой соотносятся потоки и процессы?

> При запуске приложения операционная система создает для него отдельный процесс, которому выделяется определенное адресное пространство в памяти и который изолирован от других процессов. Процесс может иметь несколько потоков. Как минимум, процесс содержит один - главный поток...
